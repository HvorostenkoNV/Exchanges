@startuml

namespace Main.Exchange{
    class Exchange << (S,#CC0000) Singleton >>{
        +run() : void
    }
}

namespace Main.Exchange.DataProcessors{
    class Manager{
        +{static}getCollector(Procedure $procedure) : Collector
        +{static}getMatcher(Procedure $procedure) : Matcher
        +{static}getCombiner(Procedure $procedure) : Combiner
        +{static}getProvider(Procedure $procedure) : Provider
    }

    interface Processor{
        +__construct(Procedures.Procedure $procedure)
        +getProcedure() : Procedures.Procedure
        +process() : void
    }

    abstract AbstractProcessor{
        +__construct(Procedures.Procedure $procedure)
        +getProcedure() : Procedures.Procedure
        +{abstract}process() : void
    }

    class Collector{
        +process() : void
        +getCollectedData() : Results.CollectorResult
    }

    class Matcher{
        +setCollectedData(CollectorResult $data) : void
        +process() : void
        +getMatchedData() : Results.MatcherResult
    }

    class Combiner{
        +setMatchedData(MatcherResult $data) : void
        +process() : void
        +getCombinedData() : Results.CombinerResult
    }

    class Provider{
        +setCombinedData(CombinerResult $data) : void
        +process() : void
    }

    Processor - Manager
    Processor <|-- AbstractProcessor
    AbstractProcessor <|-- Collector
    AbstractProcessor <|-- Matcher
    AbstractProcessor <|-- Combiner
    AbstractProcessor <|-- Provider
}

namespace Main.Exchange.DataProcessors.Results{
    interface Result{
    }

    class CollectorResult{
        +__construct(array $data)
        +getData(string $participantClassName) : array
    }

    class MatcherResult{
        +__construct(array $data)
        +getGeneralId(string $participantClassName, int $id) : int
        +getParticipantId(int $generalId) : int
    }

    class CombinerResult{
        +__construct(array $data)
        +getData() : array
    }

    Result <|-- CollectorResult
    Result <|-- MatcherResult
    Result <|-- CombinerResult

    note bottom of CollectorResult
        data structure:
        [
            ParticipantClassName =>
            [
                ParticipantItemId =>
                [
                    field => value,
                    field => value
                ],
                ParticipantItemId =>
                [
                    field => value,
                    field => value
                ]
            ]
        ]
    endnote

    note bottom of MatcherResult
        data structure:
        [
            generalItemId =>
            [
                ParticipantClassName => itemId,
                ParticipantClassName => itemId
            ]
        ]
    endnote

    note bottom of CombinerResult
        data structure:
        [
            generalItemId =>
            [
                field => value,
                field => value
            ],
            generalItemId =>
            [
                field => value,
                field => value
            ]
        ]
    endnote
}

namespace Main.Exchange.Procedures{
    class Manager{
        +{static}getProcedures() : Procedure[]
    }

    interface Procedure{
        +getParticipants() : Participants.Participant[]
        +getMatchingRules() : Rules.MatchingRules
        +getCombiningRules() : Rules.CombiningRules
    }

    abstract AbstractProcedure{
        +getParticipants() : Participants.Participant[]
        +getMatchingRules() : Rules.MatchingRules
        +getCombiningRules() : Rules.CombiningRules
    }

    class UsersExchange{

    }

    Manager - Procedure
    Procedure <|-- AbstractProcedure
    AbstractProcedure <|-- UsersExchange
}

namespace Main.Exchange.Participants{
    interface Participant{
        +getFields() : Data.FieldsMap
        +getProvidedData() : Data.ProvidedData
        +deliveryData(Data.DataForDelivery $data) : bool
    }

    abstract AbstractParticipants{
        +getFields() : Data.FieldsMap
        +getProvidedData() : Data.ProvidedData
        +deliveryData(Data.DataForDelivery $data) : bool

        -{abstract}readProvidedData() : ProvidedData
        -{abstract}provideDataForDelivery(Data.DataForDelivery $data) : bool
    }

    class Users1C{
        -readProvidedData() : ProvidedData
        -provideDataForDelivery(DataForDelivery $data) : bool
    }

    class UsersAD{
        -readProvidedData() : ProvidedData
        -provideDataForDelivery(DataForDelivery $data) : bool
    }

    class UsersBitrix{
        -readProvidedData() : ProvidedData
        -provideDataForDelivery(DataForDelivery $data) : bool
    }

    Participant <|-- AbstractParticipants
    AbstractParticipants <|-- Users1C
    AbstractParticipants <|-- UsersAD
    AbstractParticipants <|-- UsersBitrix
}

namespace Main.Exchange.Participants.Data{
    interface Data{

    }

    class ProvidedData{

    }

    class DataForDelivery{

    }

    class FieldsMap{

    }

    Data <|-- ProvidedData
    Data <|-- DataForDelivery
    Data <|-- FieldsMap
}

namespace Main.Exchange.Participants.Fields{
    interface Field{

    }

    abstract AbstractField{

    }

    class StringField{

    }

    Field <|-- AbstractField
    AbstractField <|-- StringField
}

namespace Main.Exchange.Procedures.Rules{
    interface Rules{

    }

    class MatchingRules{

    }

    class CombiningRules{

    }

    Rules <|-- MatchingRules
    Rules <|-- CombiningRules
}

Main.Exchange.Exchange .. Main.Exchange.DataProcessors.Manager
Main.Exchange.Exchange .. Main.Exchange.Procedures.Manager

Main.Exchange.DataProcessors.Processor *-- "one" Main.Exchange.DataProcessors.Results.Result
Main.Exchange.DataProcessors.Processor *-- "one" Main.Exchange.Procedures.Procedure
Main.Exchange.Procedures.Procedure *-- "many" Main.Exchange.Participants.Participant
Main.Exchange.Procedures.Procedure *-- "Many" Main.Exchange.Procedures.Rules.Rules
Main.Exchange.Participants.Participant *-- "Many" Main.Exchange.Participants.Data.Data

Main.Exchange.Participants.Data.FieldsMap *-- "Many" Main.Exchange.Participants.Fields.Field

@enduml